#include "Object.h"

///<summary>Конструктор.</summary>
Object::Object()
{
	this->name_ = "Name does not set.";

	this->translationMatrix_ = glm::mat4(1.0f);
	this->rotationMatrix_ = glm::mat4(1.0f);
	this->scaleMatrix_ = glm::mat4(1.0f);
	this->position_ = glm::vec3(0.0f);
	this->rotationAngle_ = 0.0f;
	this->rotationAxis_ = glm::vec3(0.0f, 1.0f, 0.0f);
	this->scaleCoeffs_ = glm::vec3(1.0f);

	this->useObjectMaterial_ = false;
}

///<summary>Конструктор.</summary>
///<param name = 'name'>Имя объекта.</param>
Object::Object(std::string name, Model *model)
{
	this->name_ = name;
	this->models_.push_back(model);

	this->translationMatrix_ = glm::mat4(1.0f);
	this->rotationMatrix_ = glm::mat4(1.0f);
	this->scaleMatrix_ = glm::mat4(1.0f);
	this->position_ = glm::vec3(0.0f);
	this->rotationAngle_ = 0.0f;
	this->rotationAxis_ = glm::vec3(0.0f, 1.0f, 0.0f);
	this->scaleCoeffs_ = glm::vec3(1.0f);

	this->useObjectMaterial_ = false;
}

///<summary>Конструктор.</summary>
///<param name = 'name'>Имя объекта.</param>
Object::Object(std::string name, std::vector<Model*> models)
{
	this->name_ = name;
	this->models_ = models;

	this->translationMatrix_ = glm::mat4(1.0f);
	this->rotationMatrix_ = glm::mat4(1.0f);
	this->scaleMatrix_ = glm::mat4(1.0f);
	this->position_ = glm::vec3(0.0f);
	this->rotationAngle_ = 0.0f;
	this->rotationAxis_ = glm::vec3(0.0f, 1.0f, 0.0f);
	this->scaleCoeffs_ = glm::vec3(1.0f);

	this->useObjectMaterial_ = false;
}

///<summary>Деструктор.</summary>
Object::~Object()
{
	this->models_.clear();
}

///<summary>Отрисовка объекта.
///<para>Если задан флаг "objectColors", то все модели рисуются с цветом объекта, </para>
///<para>иначе - с заданным цветом модели.</para>
///</summary>
///<param name = 'shader'>Шейдер.</param>
void Object::draw(Shader shader)
{
	if (this->models_.empty()) logger.log("Object::draw", QErrorType::error, "Models list is empty. Nothing to render.");
	else
	{
		for (size_t i = 0; i < this->models_.size(); i++)
		{
			if (useObjectMaterial_) this->models_[i]->draw(shader, this->material_);
			else this->models_[i]->draw(shader);
		}
	}
}

///<summary>Задаёт материал объекта.</summary>
///<param name = 'material'>Материал.</param>
void Object::setMaterial(QMaterial material)
{
	this->material_ = material;
}

///<summary>Задаёт флаг использования материала этого объекта для всех моделей, 
///<para>принадлежащих объекту.</para>
///<para>Приоритет выше флага модели, но ниже флага текстур.</para>
///</summary>
void Object::useObjectMaterial()
{
	this->useObjectMaterial_ = true;
}

///<summary>Добавляет модель к объекту.</summary>
///<param name = 'model'>Модель.</param>
void Object::addModel(Model *model)
{
	this->models_.push_back(model);
}

///<summary>Извлекает модель из объекта пл имени.</summary>
///<param name = 'name'>Имя извлекаемой модели.</param>
Model* Object::removeModel(const std::string name)
{
	Model *model = nullptr;

	for (size_t i = 0; i < this->models_.size(); i++)
	{
		if (this->models_[i]->getName() == name)
		{
			model = models_[i];
			this->models_.erase(models_.begin() + i);
			std::vector<Model*>(models_).swap(models_);

			return model;
		}
	}

	std::string msg = "Model \"" + name + "\" not found.";
	logger.log("Object::popModel", QErrorType::error, msg);

	return model;
}